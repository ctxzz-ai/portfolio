<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Orbital Bloom</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(circle at 50% 20%, #1e1133, #05030c 70%);
        overflow: hidden;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .overlay {
        position: absolute;
        bottom: 1.8rem;
        left: 50%;
        transform: translateX(-50%);
        font-family: 'Outfit', sans-serif;
        color: rgba(250, 246, 255, 0.75);
        letter-spacing: 0.24em;
        text-transform: uppercase;
        font-size: clamp(0.55rem, 1.3vw, 0.78rem);
        padding: 0.6rem 1.4rem;
        background: rgba(10, 3, 30, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <canvas id="orbit"></canvas>
    <div class="overlay">Orbital Bloom</div>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

      const canvas = document.getElementById('orbit');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x05030c, 1);

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 80);
      camera.position.set(-1.6, 3.8, 8.2);

      const coreGeometry = new THREE.IcosahedronGeometry(1.2, 2);
      const coreMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x8f6fff,
        roughness: 0.2,
        transmission: 0.8,
        thickness: 1.2,
        clearcoat: 0.6,
        emissive: 0x351266,
        emissiveIntensity: 0.55,
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      scene.add(core);

      const haloGeometry = new THREE.SphereGeometry(1.65, 48, 48);
      const haloMaterial = new THREE.MeshBasicMaterial({
        color: 0xb8a4ff,
        transparent: true,
        opacity: 0.18,
        side: THREE.DoubleSide,
      });
      const halo = new THREE.Mesh(haloGeometry, haloMaterial);
      scene.add(halo);

      const orbitGroup = new THREE.Group();
      scene.add(orbitGroup);

      const satelliteGeometry = new THREE.SphereGeometry(0.16, 20, 20);
      const satellites = [];
      const satelliteCount = 42;

      for (let i = 0; i < satelliteCount; i += 1) {
        const hue = 0.58 + (i / satelliteCount) * 0.15;
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(hue % 1, 0.65, 0.65),
          emissive: new THREE.Color().setHSL((hue + 0.12) % 1, 0.7, 0.4),
          emissiveIntensity: 0.6,
          roughness: 0.35,
          metalness: 0.5,
        });
        const mesh = new THREE.Mesh(satelliteGeometry, material);
        mesh.scale.setScalar(THREE.MathUtils.randFloat(0.7, 1.6));
        orbitGroup.add(mesh);

        satellites.push({
          mesh,
          radius: THREE.MathUtils.randFloat(2.4, 4.5),
          speed: THREE.MathUtils.randFloat(0.25, 0.65),
          offset: Math.random() * Math.PI * 2,
          elevation: THREE.MathUtils.randFloat(0.2, 1.2),
          tilt: THREE.MathUtils.degToRad(THREE.MathUtils.randFloatSpread(35)),
        });
      }

      const ringGeometry = new THREE.RingGeometry(2.1, 3.6, 140);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0x5f7bff,
        transparent: true,
        opacity: 0.25,
        side: THREE.DoubleSide,
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2.4;
      ring.position.y = -0.15;
      scene.add(ring);

      const starCount = 1200;
      const starPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i += 1) {
        starPositions[i * 3] = THREE.MathUtils.randFloatSpread(30);
        starPositions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(18);
        starPositions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(30);
      }
      const starGeometry = new THREE.BufferGeometry();
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.05,
        transparent: true,
        opacity: 0.7,
      });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      const ambient = new THREE.AmbientLight(0x404064, 0.7);
      const keyLight = new THREE.PointLight(0x88aaff, 2.6, 30);
      keyLight.position.set(4, 6, 6);
      const fillLight = new THREE.PointLight(0xff79c6, 1.8, 25);
      fillLight.position.set(-4.5, -2, -3);
      scene.add(ambient, keyLight, fillLight);

      const clock = new THREE.Clock();

      function resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }

      function animate() {
        const elapsed = clock.getElapsedTime();

        satellites.forEach((satellite) => {
          const angle = elapsed * satellite.speed + satellite.offset;
          const radius = satellite.radius + Math.sin(elapsed * 0.2 + satellite.offset) * 0.15;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const y = Math.sin(angle * 1.3 + satellite.tilt) * satellite.elevation;
          satellite.mesh.position.set(x, y, z);
          satellite.mesh.rotation.y = angle * 2.0;
        });

        orbitGroup.rotation.y = elapsed * 0.1;
        ring.rotation.z = Math.sin(elapsed * 0.2) * 0.2;
        halo.material.opacity = 0.15 + Math.sin(elapsed * 0.6) * 0.05;
        core.rotation.y += 0.0035;
        stars.rotation.y += 0.0004;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      resize();
      window.addEventListener('resize', resize);
      animate();
    </script>
  </body>
</html>
